import json

FLAGS = {
    'Z': 'Function',
    'N': 'Function',
    'H': 'Function',
    'C': 'Function',
    '1': 'Set',
    '0': 'Reset',
    '-': 'Unchanged',
}


OPERANDS = {
    'A': 'Register(0)',
    'F': 'Register(1)',
    'B': 'Register(2)',
    'C': 'Register(3)',
    'D': 'Register(4)',
    'E': 'Register(5)',
    'H': 'Register(6)',
    'L': 'Register(7)',
    'SP': 'SP',
    'BC': 'RegisterPair(2, 3)',
    'DE': 'RegisterPair(4, 5)',
    'HL': 'RegisterPair(6, 7)',
    'AF': 'RegisterPair(1, 2)',
    'Z': 'Zero',
    'NZ': 'NonZero',
    'Ca': 'Carry',
    'NC': 'NonCarry',
    'd8': 'Immediate(8)',
    'd16': 'Immediate(16)',
    'a8': 'Address(8)',
    'a16': 'Address(16)',
    'r8': 'Offset(8)',
    'SP+r8': 'SPOffset(8)',
    'COff': 'COffset(8)',
    '00H': 'RSTOffset(0x00)',
    '08H': 'RSTOffset(0x08)',
    '10H': 'RSTOffset(0x10)',
    '18H': 'RSTOffset(0x18)',
    '20H': 'RSTOffset(0x20)',
    '28H': 'RSTOffset(0x28)',
    '30H': 'RSTOffset(0x30)',
    '38H': 'RSTOffset(0x38)',
    '0': 'Bit(0)',
    '1': 'Bit(1)',
    '2': 'Bit(2)',
    '3': 'Bit(3)',
    '4': 'Bit(4)',
    '5': 'Bit(5)',
    '6': 'Bit(6)',
    '7': 'Bit(7)',
}

TEMPLATE = """// Generated by opsgen.py
use instructions::{
    Definition,
    Flag,
    Mnemonic,
    OpCode,
    Operand,
};
use std::collections::HashMap;

pub type InstructionSet = HashMap<OpCode, Definition>;

lazy_static! {
    pub static ref INSTRUCTIONS: InstructionSet = {
        let mut map = HashMap::new();
        %s
        map
    };
}"""


class Instruction(object):
    def __init__(self, code, mnemonic, cycles, flags, operands):
        self.code = code
        self.mnemonic = mnemonic
        self.cycles = cycles
        self.flags = flags
        self.operands = operands

        self._strip_parentheses()
        self._fix_mnemonic()
        self._translate_flags()
        self._translate_operands()

    def _strip_parentheses(self):
        self.operands = [o.replace('(C)', 'COff').replace('(', '').replace(')', '')
                         for o in self.operands]

    def _fix_mnemonic(self):
        if 'HL-' in self.operands and self.mnemonic == 'LD':
            self.mnemonic = 'LDD'
        if 'HL+' in self.operands and self.mnemonic == 'LD':
            self.mnemonic = 'LDI'
        self.operands = [o.replace('HL+', 'HL').replace('HL-', 'HL')
                         for o in self.operands]

    def _translate_flags(self):
        self.flags = [FLAGS[f] for f in self.flags]

    def _translate_operands(self):
        self.operands = [OPERANDS[o] if o in OPERANDS else o for o in self.operands]

    def __repr__(self):
        ops = ', '.join(self.operands)
        return '0x%04x: %s %s' % (self.code, self.mnemonic, ops)

    def to_rust(self):
        flags = ['Flag::%s' % f for f in self.flags]
        operands = ['Operand::%s' % o for o in self.operands]
        return '''Definition {
            mnemonic: Mnemonic::%s,
            code: 0x%x,
            cycles: %s,
            operands: [%s],
            flags: [%s],
        }''' % (
            self.mnemonic,
            self.code,
            self.cycles,
            ', '.join(operands),
            ', '.join(flags)
        )


def parse_instruction(ins, prefixed):
    code = int(ins['addr'], 16)
    if prefixed:
        code += 0xcb00

    operands = []
    if 'operand1' in ins:
        operands.append(ins['operand1'])
    else:
        operands.append('None')
    if 'operand2' in ins:
        operands.append(ins['operand2'])
    else:
        operands.append('None')

    if len(ins['cycles']) == 1:
        ins['cycles'].append(0)

    return Instruction(
        code,
        ins['mnemonic'],
        ins['cycles'],
        ins['flags'],
        operands
    )


def to_lazy_static(ins):
    inserts = ['map.insert(0x%x, %s);' % (i.code, i.to_rust()) for i in ins]
    return TEMPLATE % '\n        '.join(inserts)


if __name__ == '__main__':
    instructions = []
    with open('./opcodes.json') as f:
        ins = json.load(f)
        for _, i in ins['unprefixed'].items():
            instructions.append(parse_instruction(i, False))
        for _, i in ins['cbprefixed'].items():
            instructions.append(parse_instruction(i, True))

    instructions.sort(key=lambda i: i.code)
    print(to_lazy_static(instructions))
