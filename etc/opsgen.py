import json

FLAGS = {
    'Z': 'Function',
    'N': 'Function',
    'H': 'Function',
    'C': 'Function',
    '1': 'Set',
    '0': 'Reset',
    '-': 'Unchanged',
}


OPERANDS = {
    'A': 'Register(0)',
    'F': 'Register(1)',
    'B': 'Register(2)',
    'C': 'Register(3)',
    'D': 'Register(4)',
    'E': 'Register(5)',
    'H': 'Register(6)',
    'L': 'Register(7)',
    '(A)': 'RegisterAddr(0)',
    '(F)': 'RegisterAddr(1)',
    '(B)': 'RegisterAddr(2)',
    '(C)': 'RegisterAddr(3)',
    '(D)': 'RegisterAddr(4)',
    '(E)': 'RegisterAddr(5)',
    '(H)': 'RegisterAddr(6)',
    '(L)': 'RegisterAddr(7)',
    'SP': 'SP',
    'BC': 'RegisterPair(2, 3)',
    'DE': 'RegisterPair(4, 5)',
    'HL': 'RegisterPair(6, 7)',
    'AF': 'RegisterPair(0, 1)',
    '(BC)': 'RegisterPairAddr(2, 3)',
    '(DE)': 'RegisterPairAddr(4, 5)',
    '(HL)': 'RegisterPairAddr(6, 7)',
    '(AF)': 'RegisterPairAddr(0, 1)',
    'Z': 'Zero',
    'NZ': 'NonZero',
    'Ca': 'Carry',
    'NC': 'NonCarry',
    'd8': 'Immediate(8)',
    'd16': 'Immediate(16)',
    'a8': 'Address(8)',
    'a16': 'Address(16)',
    '(a8)': 'Address(8)',
    '(a16)': 'Address(16)',
    'r8': 'Offset(8)',
    'SP+r8': 'SPOffset(8)',
    '00H': 'RSTOffset(0x00)',
    '08H': 'RSTOffset(0x08)',
    '10H': 'RSTOffset(0x10)',
    '18H': 'RSTOffset(0x18)',
    '20H': 'RSTOffset(0x20)',
    '28H': 'RSTOffset(0x28)',
    '30H': 'RSTOffset(0x30)',
    '38H': 'RSTOffset(0x38)',
    '0': 'Bit(0)',
    '1': 'Bit(1)',
    '2': 'Bit(2)',
    '3': 'Bit(3)',
    '4': 'Bit(4)',
    '5': 'Bit(5)',
    '6': 'Bit(6)',
    '7': 'Bit(7)',
}


IMMEDIATE_TYPES = {
    'Immediate(8)': 'ImmediateType::Byte',
    'Address(8)': 'ImmediateType::Byte',
    'Offset(8)': 'ImmediateType::Byte',
    'SPOffset(8)': 'ImmediateType::Byte',
    'Address(16)': 'ImmediateType::Short',
    'Immediate(16)': 'ImmediateType::Short'
}


TEMPLATE = """// Generated by opsgen.py
use definition::{
    Definition,
    Flag,
    Mnemonic,
    OpCode,
    Operand,
    ImmediateType,
    INVALID,
};

static INSTRUCTIONS: [Definition; 512] = [
    %s
];

pub fn get_definition(code: OpCode) -> &'static Definition {
    let extended = code & 0xcb00 != 0;
    if !extended {
        &INSTRUCTIONS[code as usize]
    } else {
        &INSTRUCTIONS[((code & 0xff) + 256) as usize]
    }
}"""


class Instruction(object):
    def __init__(self, code, mnemonic, length, cycles, flags, operands):
        self.code = code
        self.mnemonic = mnemonic
        self.length = length
        self.cycles = cycles
        self.flags = flags
        self.operands = operands

        self._fix_mnemonic()
        self._translate_flags()
        self._translate_operands()

    def _fix_mnemonic(self):
        if '(HL-)' in self.operands and self.mnemonic == 'LD':
            self.mnemonic = 'LDD'
        if '(HL+)' in self.operands and self.mnemonic == 'LD':
            self.mnemonic = 'LDI'
        self.operands = [o.replace('HL+', 'HL').replace('HL-', 'HL')
                         for o in self.operands]

    def _translate_flags(self):
        self.flags = [FLAGS[f] for f in self.flags]

    def _translate_operands(self):
        self.operands = [OPERANDS[o] if o in OPERANDS else o for o in self.operands]

    def _get_immediate_size(self):
        for o in self.operands:
            if o in IMMEDIATE_TYPES:
                return 'Some(%s)' % IMMEDIATE_TYPES[o]
        return 'None'

    def __repr__(self):
        ops = ', '.join(self.operands)
        return '0x%04x: %s %s' % (self.code, self.mnemonic, ops)

    def to_rust(self):
        flags = ['Flag::%s' % f for f in self.flags]
        operands = ['Operand::%s' % o for o in self.operands]
        return '''Definition {
        mnemonic: Mnemonic::%s,
        code: 0x%x,
        length: %d,
        cycles: %s,
        operands: [%s],
        flags: [%s],
        immediate_size: %s,
    }''' % (
            self.mnemonic,
            self.code,
            self.length,
            self.cycles,
            ', '.join(operands),
            ', '.join(flags),
            self._get_immediate_size()
        )


def parse_instruction(ins, prefixed):
    code = int(ins['addr'], 16)
    if prefixed:
        code += 0xcb00

    operands = []
    if 'operand1' in ins:
        operands.append(ins['operand1'])
    else:
        operands.append('None')
    if 'operand2' in ins:
        operands.append(ins['operand2'])
    else:
        operands.append('None')

    if len(ins['cycles']) == 1:
        ins['cycles'].append(0)

    return Instruction(
        code,
        ins['mnemonic'],
        ins['length'],
        ins['cycles'],
        ins['flags'],
        operands
    )


def to_lazy_static(ins):
    lookup = {i.code: i for i in ins}
    inserts = []
    for i in range(256):
        if i not in lookup:
            inserts.append("INVALID")
        else:
            inserts.append(lookup[i].to_rust())

    for i in range(256):
        inserts.append(lookup[0xcb00 + i].to_rust())

    # inserts = ['map.insert(0x%x, %s);' % (i.code, i.to_rust()) for i in ins]
    return TEMPLATE % ',\n    '.join(inserts)


if __name__ == '__main__':
    instructions = []
    with open('./opcodes.json') as f:
        ins = json.load(f)
        for _, i in ins['unprefixed'].items():
            instructions.append(parse_instruction(i, False))
        for _, i in ins['cbprefixed'].items():
            instructions.append(parse_instruction(i, True))

    instructions.sort(key=lambda i: i.code)
    print(to_lazy_static(instructions))
